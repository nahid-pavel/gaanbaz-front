// Generated by CoffeeScript 1.8.0
(function() {
  var Elapsed, PleasantProgress, Util, colors, dateFormat, highlightTicksWidth, logSymbols, progress, progressStartDate, sticker_messages, sticker_raw_messages, _;

  colors = require('colors');

  dateFormat = require('dateformat');

  logSymbols = require('./symbols');

  PleasantProgress = require('pleasant-progress');

  progress = new PleasantProgress();

  Elapsed = require('elapsed');

  _ = require('underscore');

  progressStartDate = null;

  highlightTicksWidth = 0;

  sticker_raw_messages = [];

  sticker_messages = [];

  Util = (function() {
    function Util() {
      this.bracks_on = "[".dim;
      this.bracks_off = "] ".dim;
    }

    Util.prototype.indentifierVerb = function(a, b) {
      if (a && b) {
        return " at ".dim;
      } else {
        return '';
      }
    };

    Util.prototype.logBuilder = function(type, message, identifier, showDateTime, trace, filePath, iconic, format) {
      var console_string, formattedDate;
      console_string = '';
      if (identifier || showDateTime) {
        console_string += this.bracks_on;
        if (identifier) {
          console_string += identifier.dim;
        }
      }
      console_string += this.indentifierVerb(identifier, showDateTime);
      if (showDateTime) {
        formattedDate = this.toDate(format);
        console_string += formattedDate;
      }
      if (identifier || showDateTime) {
        console_string += this.bracks_off;
      }
      console_string += this.makeColors(type);
      if (filePath) {
        console_string += this.showFilePath(filePath);
      }
      console_string += message;
      if (iconic) {
        console_string += " " + this.makeIcons(type);
      }
      if (trace) {
        console_string += this.renderTrace(trace);
      }
      console.log(console_string);
    };

    Util.prototype.toDate = function(format) {
      return dateFormat(new Date(), format).dim;
    };

    Util.prototype.makeColors = function(type) {
      switch (type) {
        case 'error':
          return 'ERR!'.bgRed.white + " ";
        case 'success':
          return 'SUCCESS'.bgGreen.white + " ";
        case 'warn':
          return 'WARN'.bgYellow.white + " ";
        case 'info':
          return 'INFO'.bgCyan + " ";
        default:
          return '';
      }
    };

    Util.prototype.makeIcons = function(type) {
      switch (type) {
        case 'error':
          return "" + logSymbols.error;
        case 'success':
          return "" + logSymbols.success;
        case 'warn':
          return "" + logSymbols.warning;
        case 'info':
          return "" + logSymbols.info;
        default:
          return '';
      }
    };

    Util.prototype.renderTrace = function(trace) {
      var e, t;
      try {
        t = JSON.stringify(trace, null, 4);
        return "\nTRACE".bgMagenta.white + " " + t;
      } catch (_error) {
        e = _error;
        return "";
      }
    };

    Util.prototype.showFilePath = function(path) {
      if (typeof path === 'string') {
        path = path.split('/');
        return path[path.length - 1].magenta + ' ';
      } else {
        return '';
      }
    };

    Util.prototype.printAction = function(type, action_name, message) {
      switch (type) {
        case 'error':
          return console.log("" + action_name.red + " " + message);
        case 'success':
          return console.log("" + action_name.green + " " + message);
        case 'warn':
          return console.log("" + action_name.yellow + " " + message);
        case 'info':
          return console.log("" + action_name.cyan + " " + message);
      }
    };

    Util.prototype.startProgress = function(identifier, message, format) {
      if (!progressStartDate) {
        progressStartDate = new Date;
        console.log(identifier.underline + " (".dim + dateFormat(progressStartDate, format).dim + ")".dim);
        return progress.start(message);
      }
    };

    Util.prototype.stopProgress = function() {
      var elapsedTime;
      progress.stop();
      elapsedTime = new Elapsed(progressStartDate, new Date());
      progressStartDate = null;
      elapsedTime = elapsedTime.optimal || ("" + elapsedTime.milliSeconds + " ms");
      return console.log("Total".bold + " " + elapsedTime.bold);
    };

    Util.prototype.startHighlight = function(message) {
      var leftCols, messageLength, totalCols;
      totalCols = process.stdout.columns;
      messageLength = message.length;
      leftCols = totalCols - messageLength;
      if (leftCols > 0) {
        highlightTicksWidth = messageLength + 10;
      } else {
        highlightTicksWidth = messageLength + 4;
      }
      console.log(this.drawTicks(highlightTicksWidth));
      console.log("" + (this.tickMessage(messageLength, highlightTicksWidth).bgWhite) + message.bgWhite.black + (this.tickMessage(messageLength, highlightTicksWidth).bgWhite));
      return console.log(this.drawTicks(highlightTicksWidth));
    };

    Util.prototype.endHighlight = function() {
      return console.log(this.drawTicks(highlightTicksWidth));
    };

    Util.prototype.drawTicks = function(count) {
      var ticks, x, _i;
      ticks = '';
      for (x = _i = 1; 1 <= count ? _i <= count : _i >= count; x = 1 <= count ? ++_i : --_i) {
        ticks += '-';
      }
      return ticks;
    };

    Util.prototype.colorsClone = colors;

    Util.prototype.tickMessage = function(messageLength, count, avoidDivider) {
      var leftCount, ticks, x, _i;
      if (avoidDivider) {
        leftCount = count - messageLength;
      } else {
        leftCount = (count - messageLength) / 2;
      }
      ticks = '';
      for (x = _i = 2; 2 <= leftCount ? _i <= leftCount : _i >= leftCount; x = 2 <= leftCount ? ++_i : --_i) {
        ticks += ' ';
      }
      return ticks;
    };

    Util.prototype.romanize = function(num) {
      var digits, i, key, roman;
      if (!+num) {
        return false;
      }
      digits = String(+num).split("");
      key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
      roman = "";
      i = 3;
      while (i--) {
        roman = (key[+digits.pop() + (i * 10)] || "") + roman;
        return Array(+digits.join("") + 1).join("M") + roman.toLowerCase();
      }
    };

    Util.prototype.printList = function(type, steps, indentLevel) {
      var self, spacer, x;
      spacer = spacer || "";
      self = this;
      x = 0;
      return steps = _.map(steps, function(v, k) {
        if (typeof v === 'object') {
          return self.printList(type, v, 1);
        } else {
          x++;
          return console.log(self.setIndent(x, v, indentLevel, type, spacer));
        }
      });
    };

    Util.prototype.stickerMessage = function(message) {
      var raw;
      raw = message.replace(/\u001b\[.*?m/g, "");
      sticker_messages.push(message);
      return sticker_raw_messages.push(raw || message);
    };

    Util.prototype.showSticker = function(align, color) {
      var longest_message, pipe, self, stickTick, stickerWidth, x, _i;
      self = this;
      pipe = '│';
      stickTick = '';
      longest_message = _.max(sticker_messages, function(message) {
        return message.length;
      });
      stickerWidth = longest_message.length + 6;
      for (x = _i = -1; -1 <= stickerWidth ? _i <= stickerWidth : _i >= stickerWidth; x = -1 <= stickerWidth ? ++_i : --_i) {
        stickTick += '─';
      }
      console.log("┌"[color] + stickTick[color] + "┐"[color]);
      _.each(sticker_messages, function(v, k) {
        var lastLength, sticker_length;
        sticker_length = sticker_raw_messages[k].length;
        switch (align) {
          case 'left':
            return console.log("" + pipe[color] + " " + v + " " + (self.tickMessage(sticker_length, stickerWidth, true)) + " " + pipe[color]);
          default:
            lastLength = self.tickMessage(sticker_length, stickerWidth).length;
            return console.log("" + pipe[color] + (self.tickMessage(sticker_length, stickerWidth)) + " " + v + " " + (self.tickMessage(sticker_length, stickerWidth)) + " " + (self.missingTicks(sticker_length, lastLength, stickerWidth)) + " " + pipe[color]);
        }
      });
      console.log("└"[color] + stickTick[color] + "┘"[color]);
      sticker_messages = [];
      return sticker_raw_messages = [];
    };

    Util.prototype.missingTicks = function(wordLength, gapLength, stickerWidth) {
      var leftWidth, ticks, totalWidth, x, _i;
      totalWidth = wordLength + 2 + gapLength * 2;
      leftWidth = stickerWidth - totalWidth;
      ticks = '';
      for (x = _i = 0; 0 <= leftWidth ? _i < leftWidth : _i > leftWidth; x = 0 <= leftWidth ? ++_i : --_i) {
        ticks += ' ';
      }
      return ticks;
    };

    Util.prototype.setIndent = function(num, message, level, type) {
      var spacer;
      spacer = "    ";
      level = level || 0;
      switch (level) {
        case 0:
          if (type === 'ol') {
            return "" + num + ". " + message;
          } else {
            return "• " + message;
          }
          break;
        case 1:
          if (type === 'ol') {
            return "" + spacer + (this.romanize(num)) + ". " + message;
          } else {
            return "" + spacer + "○ " + message;
          }
      }
    };

    return Util;

  })();

  module.exports = Util;

}).call(this);
